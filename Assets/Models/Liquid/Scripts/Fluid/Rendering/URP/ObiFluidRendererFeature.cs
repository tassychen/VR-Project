#if UNITY_2019_2_OR_NEWER && SRP_UNIVERSAL
using System;using UnityEngine;using UnityEngine.Rendering;#if UNITY_2023_3_OR_NEWERusing UnityEngine.Rendering.RenderGraphModule;
#endifusing UnityEngine.Rendering.Universal;using UnityEngine.XR;namespace Obi{    public class ObiFluidRendererFeature : ScriptableRendererFeature    {        public ObiFluidRenderingPass[] passes;        [Range(1, 4)]        public int thicknessDownsample = 1;        [Min(0)]        public float foamFadeDepth = 1.0f;        private VolumePass m_VolumePass;        public override void Create()        {            if (passes == null)                return;            m_VolumePass = new VolumePass();            m_VolumePass.renderPassEvent = RenderPassEvent.AfterRenderingOpaques;        }        public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)        {            if (passes == null)                return;            m_VolumePass.Setup(passes, thicknessDownsample, foamFadeDepth);

            // request camera  depth and color buffers.
            m_VolumePass.ConfigureInput(ScriptableRenderPassInput.Depth | ScriptableRenderPassInput.Color);            renderer.EnqueuePass(m_VolumePass);        }        protected override void Dispose(bool disposing)        {            m_VolumePass.Dispose();        }    }    public class VolumePass : ScriptableRenderPass    {        const string k_ThicknessPassTag = "FluidThicknessPass";        private ProfilingSampler m_Thickness_Profile = new ProfilingSampler(k_ThicknessPassTag);        private ObiFluidRenderingPass[] passes;        private int thicknessDownsample;        private float foamFadeDepth;        private Material m_TransmissionMaterial;        private RTHandle m_TransmissionHandle;        private RTHandle m_FoamHandle;        private RTHandle m_SurfHandle;        private RTHandle m_DepthHandle;        private class PassData        {            internal ObiFluidRenderingPass[] passes;            internal float foamFadeDepth;            internal Material m_TransmissionMaterial;            internal ProfilingSampler m_Thickness_Profile;            internal RTHandle m_TransmissionHandle;            internal RTHandle m_FoamHandle;            internal RTHandle m_SurfHandle;            internal RTHandle m_DepthHandle;        }        private XRSettings.StereoRenderingMode stereoMode = XRSettings.StereoRenderingMode.MultiPass;        protected Material CreateMaterial(Shader shader)        {            if (!shader || !shader.isSupported)                return null;            Material m = new Material(shader);            m.hideFlags = HideFlags.HideAndDontSave;            return m;        }        public void Setup(ObiFluidRenderingPass[] passes, int thicknessDownsample, float foamFadeDepth)        {
            // Copy settings;
            this.passes = passes;            this.thicknessDownsample = thicknessDownsample;            this.foamFadeDepth = foamFadeDepth;            m_TransmissionMaterial = CreateMaterial(Shader.Find("Hidden/AccumulateTransmissionURP"));            if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))            {                Debug.LogWarning("Obi Fluid Renderer Feature not supported in this platform.");                return;             }        }

        public void Dispose()        {            m_TransmissionHandle?.Release();            m_SurfHandle?.Release();            m_DepthHandle?.Release();            m_FoamHandle?.Release();        }

#region PASS_SHARED_RENDERING_CODE
        void SetupResources(RenderTextureDescriptor desc)        {            var camSize = new Vector2Int(desc.width, desc.height);            if (m_SurfHandle == null || camSize != m_SurfHandle.referenceSize || XRSettings.stereoRenderingMode != stereoMode)            {                m_TransmissionHandle?.Release();                m_FoamHandle?.Release();                m_DepthHandle?.Release();                m_SurfHandle?.Release();

                // Support for single pass instanced stereo: buffers must be texture arrays of dimension 2 (one entry per eye).
                stereoMode = XRSettings.stereoRenderingMode;
                //VRTextureUsage vrUsage = stereoMode == XRSettings.StereoRenderingMode.SinglePassInstanced ? VRTextureUsage.TwoEyes : VRTextureUsage.None;
                TextureDimension dimension = stereoMode == XRSettings.StereoRenderingMode.SinglePassInstanced ? TextureDimension.Tex2DArray : TextureDimension.Tex2D;                int slices = stereoMode == XRSettings.StereoRenderingMode.SinglePassInstanced ? 2 : 1;                m_TransmissionHandle = RTHandles.Alloc(desc.width / thicknessDownsample, desc.height / thicknessDownsample, slices, name: "_FluidThickness", colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat.R32G32B32A32_SFloat, /*vrUsage: vrUsage,*/ dimension: dimension);                m_SurfHandle = RTHandles.Alloc(desc.width, desc.height, slices, name: "_TemporaryBuffer", colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat.R32G32B32A32_SFloat, /*vrUsage: vrUsage,*/ dimension: dimension);                m_DepthHandle = RTHandles.Alloc(desc.width, desc.height, slices, name: "_TemporaryBufferDepth", depthBufferBits: DepthBits.Depth16, colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat.R32G32B32A32_SFloat, /*vrUsage: vrUsage,*/ dimension: dimension);                m_FoamHandle = RTHandles.Alloc(desc.width, desc.height, slices, name: "_Foam", colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat.R8G8B8A8_UNorm, /*vrUsage: vrUsage,*/ dimension: dimension);            }        }        static void PopulateComandBuffer(CommandBuffer cmd, PassData passData)        {            cmd.SetGlobalTexture("_TemporaryBuffer", passData.m_SurfHandle);            cmd.SetGlobalTexture("_TemporaryBufferStereo", passData.m_SurfHandle);            cmd.SetRenderTarget(passData.m_TransmissionHandle, 0, CubemapFace.Unknown, -1);            cmd.ClearRenderTarget(false, true, FluidRenderingUtils.transmissionBufferClear);

            // render each pass (there's only one mesh per pass) onto temp buffer to calculate its color and thickness.
            for (int i = 0; i < passData.passes.Length; ++i)            {                if (passData.passes[i] != null && passData.passes[i].renderers.Count > 0)                {                    var fluidMesher = passData.passes[i].renderers[0];                    if (fluidMesher.actor.isLoaded)                    {                        cmd.SetRenderTarget(passData.m_SurfHandle, passData.m_DepthHandle, 0, CubemapFace.Unknown, -1);                        cmd.ClearRenderTarget(false, true, FluidRenderingUtils.thicknessBufferClear);

                        // fluid mesh renders absorption color and thickness onto temp buffer:
                        var renderSystem = fluidMesher.actor.solver.GetRenderSystem<ObiFluidSurfaceMesher>() as IFluidRenderSystem;                        if (renderSystem != null)                            renderSystem.RenderVolume(cmd, passData.passes[i], fluidMesher);

                        // calculate transmission from thickness & absorption and accumulate onto transmission buffer.
                        cmd.SetGlobalFloat("_Thickness", passData.passes[i].thickness);                        Blitter.BlitCameraTexture(cmd, passData.m_SurfHandle, passData.m_TransmissionHandle, passData.m_TransmissionMaterial, 0);                    }                }            }

            // get temporary buffer with depth support, render fluid surface depth:
            cmd.SetRenderTarget(passData.m_SurfHandle, passData.m_DepthHandle, 0, CubemapFace.Unknown, -1);            cmd.ClearRenderTarget(true, true, Color.clear);            for (int i = 0; i < passData.passes.Length; ++i)            {                if (passData.passes[i] != null && passData.passes[i].renderers.Count > 0)                {                    var fluidMesher = passData.passes[i].renderers[0];                    if (fluidMesher.actor.isLoaded)                    {
                        // fluid mesh renders surface onto surface buffer
                        var renderSystem = fluidMesher.actor.solver.GetRenderSystem<ObiFluidSurfaceMesher>() as IFluidRenderSystem;                        if (renderSystem != null)                            renderSystem.RenderSurface(cmd, passData.passes[i], fluidMesher);                    }                }            }

            // render foam, using distance to surface depth to modulate alpha:
            cmd.SetRenderTarget(passData.m_FoamHandle, 0, CubemapFace.Unknown, -1);            cmd.ClearRenderTarget(false, true, Color.clear);            for (int i = 0; i < passData.passes.Length; ++i)            {                for (int j = 0; j < passData.passes[i].renderers.Count; ++j)                {                    if (passData.passes[i].renderers[j].TryGetComponent(out ObiFoamGenerator foamGenerator))                    {                        var solver = passData.passes[i].renderers[j].actor.solver;                        if (solver != null)                        {                            var rend = solver.GetRenderSystem<ObiFoamGenerator>() as ObiFoamRenderSystem;                            if (rend != null)                            {                                rend.renderBatch.material.SetFloat("_FadeDepth", passData.foamFadeDepth);                                rend.renderBatch.material.SetFloat("_VelocityStretching", solver.maxFoamVelocityStretch);                                rend.renderBatch.material.SetFloat("_FadeIn", solver.foamFade.x);                                rend.renderBatch.material.SetFloat("_FadeOut", solver.foamFade.y);                                cmd.DrawMesh(rend.renderBatch.mesh, solver.transform.localToWorldMatrix, rend.renderBatch.material);                            }                        }                    }                }            }            cmd.SetGlobalTexture("_FluidThickness", passData.m_TransmissionHandle);            cmd.SetGlobalTexture("_FluidThicknessStereo", passData.m_TransmissionHandle);            cmd.SetGlobalTexture("_Foam", passData.m_FoamHandle);            cmd.SetGlobalTexture("_FoamStereo", passData.m_FoamHandle);        }

        #endregion
        #region PASS_NON_RENDER_GRAPH_PATH
#if UNITY_2023_3_OR_NEWER        [System.Obsolete("This rendering path is for compatibility mode only (when Render Graph is disabled). Use Render Graph API instead.", false)]
#endif        public override void OnCameraSetup(CommandBuffer cmd, ref RenderingData renderingData)        {            SetupResources(renderingData.cameraData.cameraTargetDescriptor);            ConfigureTarget(m_TransmissionHandle);            ConfigureClear(ClearFlag.All, FluidRenderingUtils.transmissionBufferClear);            ConfigureTarget(m_SurfHandle);            ConfigureClear(ClearFlag.All, FluidRenderingUtils.thicknessBufferClear);        }

#if UNITY_2023_3_OR_NEWER        [System.Obsolete("This rendering path is for compatibility mode only (when Render Graph is disabled). Use Render Graph API instead.", false)]
#endif        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)        {            CommandBuffer cmd = CommandBufferPool.Get(k_ThicknessPassTag);            using (new ProfilingScope(cmd, m_Thickness_Profile))            {                var passData = new PassData();                passData.passes = passes;                passData.m_Thickness_Profile = m_Thickness_Profile;                passData.m_TransmissionMaterial = m_TransmissionMaterial;                passData.foamFadeDepth = foamFadeDepth;                passData.m_TransmissionHandle = m_TransmissionHandle;                passData.m_SurfHandle = m_SurfHandle;                passData.m_DepthHandle = m_DepthHandle;                passData.m_FoamHandle = m_FoamHandle;                PopulateComandBuffer(cmd, passData);            }            context.ExecuteCommandBuffer(cmd);            cmd.Clear();            CommandBufferPool.Release(cmd);        }

#endregion

#region PASS_RENDER_GRAPH_PATH
#if UNITY_2023_3_OR_NEWER        public override void RecordRenderGraph(RenderGraph renderGraph, ContextContainer frameData)        {            using (var builder = renderGraph.AddUnsafePass<PassData>(k_ThicknessPassTag, out var passData))            {                UniversalCameraData cameraData = frameData.Get<UniversalCameraData>();                SetupResources(cameraData.cameraTargetDescriptor);                passData.passes = passes;                passData.m_Thickness_Profile = m_Thickness_Profile;                passData.m_TransmissionMaterial = m_TransmissionMaterial;                passData.foamFadeDepth = foamFadeDepth;

                passData.m_TransmissionHandle = m_TransmissionHandle;                passData.m_SurfHandle = m_SurfHandle;                passData.m_DepthHandle = m_DepthHandle;                passData.m_FoamHandle = m_FoamHandle;                builder.AllowPassCulling(false);

                // Assigns the ExecutePass function to the render pass delegate. This will be called by the render graph when executing the pass.
                builder.SetRenderFunc((PassData passData, UnsafeGraphContext context) => ExecutePass(passData, context));            }        }
        static void ExecutePass(PassData passData, UnsafeGraphContext context)        {            CommandBuffer cmd = CommandBufferHelpers.GetNativeCommandBuffer(context.cmd);//CommandBufferPool.Get("FluidThicknessPass");
            using (new ProfilingScope(cmd, passData.m_Thickness_Profile))            {                PopulateComandBuffer(cmd, passData);            }        }
        
#endif
#endregion

    }}


#endif